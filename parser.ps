%!

% Stackbasierte Sprachen - WS 2010
%
% Matthias Tretter - 0726390
% Philip Messlehner - 
% Perl Thomas -
%

% current known limitations:
%  * input-file must have an empty line at the end

% Ein simpler XML-Parser in PostScript

% Stack-Effekt-Kommentare haben die Form
% SE funtionsname: parameter1 parameter2 parameterX -- returnwert1 returnwert2 returnwertX

% Global Tag Dictionary
/TagDictionary 100 dict def
/Topmost (unknown) def



% Procedure to exclude Attribute
% SE prepareTag: tagWithAttributes -- tag
/prepareTag {
	/TagDictionary exch % pusht TagDict on the stack vor tag
	( ) search { % search for whitespace
		exch	 % new ordering post pre match
		pop		 % pop whitespace
		exch	 % new ordering pre post
		%pop		 % pop Attributes

		% store into TagDictionary (name = pre (tag-name), value = post (attributes))
		%TagDictionary 
		%    def % store tag on dictionary-stack   
		%end
		put
	} 
	{ % else-path search (element has no attributes)
		TagDictionary begin
		   % store into TagDictionary (name = pre (tag-name), value = 'no tags')
		   (no tags) def 
		end
	} ifelse
	
} def

% Procedure to handle End-Tag
% SE handleEndTag: endTag --
/handleEndTag {
	% TODO: compare current element to handle with top of dictionary-stack
	(Current Element to handle: ) print
	print % print current element
	%TagDictionary printDictionaryTop % print top of dictionary
	
	(\n) print
} def

% Define Procedure for handling SearchTerm
% SE analyzeSearchResult: pre --
/analyzeSearchResult {
	% searching for '</' in pre 	(SE search: string -- post match pre true 
    %                                        OR string -- false)
	(</) search {
		% EndTag Found
		pop		% pop pre (Text before Tag begins)
		pop		% pop '</'
		handleEndTag
	} % if-path search
	{ % else-path search
		(<) search { % search for BeginTag
			pop		% pop pre (Text before Tag begins)
			pop		% pop '<'
			
			prepareTag
			(Tag found\n) print
		}
		{
			pop
		} ifelse
	} ifelse
} def


% prints a dictionary
% SE printDictionary dictionary  –-
/printDictionary { %def
	(\nDictionary: \n) print
	{ %forall
		exch % name first
	    (key: ) print ==  
	    %( = ) print  
	    (val: ) print ==
    } forall 
} bind def

% prints the top of a dictionary
% SE printDictionary dictionary  –-
/printDictionaryTop { %def
	(\nDictionary Top: \n) print
	{ %forall
		exch % name first
	    (key: ) print ==  
	    %( = ) print  
	    (val: ) print ==
		exit
    } forall 
} bind def


% Reads the path to a file from stdin
% SE readPathToInputFile:  -- path
/readPathToInputFile {
    % TODO: comment out, hardcoded for testing-purposes
	%(Pfad zur XML-Datei: ) print flush
    %(%stdin) (r) file 100 string readline pop
	(input/valid1.xml)
} def

% Main-Procedure
% SE main:  --
/main {
	/buffer 128 string def				%setup buffer for readline
	currentfile buffer readline
	
	/input readPathToInputFile (r) file def	%defines Inputfile
	
	{ % start loop
		% reading one line (SE readline: input buffer -- string bool)
		input buffer readline {
			{ %start loop for multiple tags in one line
				% searching for '>'	(SE search: string -- post match pre true 
		    		%                            OR string -- false)
					(>) search {			
						analyzeSearchResult
						pop		% pop match ( > Sign )
					} % if-path
					{ % else-path (search)
						pop						% pops string of search command
						exit					% and exits loop
					} ifelse
			} loop
		}
		{ % else-path (readline)
			pop		% pops string for readline command
			exit	% and exits loop
		} ifelse
	} loop

	% close File
	input closefile
	
	TagDictionary printDictionary
} def

% call main-procedure
main
