%!

% Stackbasierte Sprachen - WS 2010
%
% Matthias Tretter - 0726390
% Philip Messlehner - 0728061
% Perl Thomas - 0725603
%

% current known limitations:
%  * input-file must have an empty line at the end

% Ein simpler XML-Parser in PostScript

% Stack-Effekt-Kommentare haben die Form
% SE funtionsname: parameter1 parameter2 parameterX -- returnwert1 returnwert2 returnwertX

/debug false def

/printa {
    debug {
        print
    } {
        pop
    } ifelse
} def

/comment {
    debug {
        =
    } {
        pop
    } ifelse
} def


% Get name of last opened tag (based on dict stack)
% SE lastTagName: -- nameOfLastOpenedTag
/lastTagName {
    % assertion: currentdict only has one key!
    currentdict length 1 ne {
        (ERROR: Found dict with size != 1) =
        currentdict printDictionary
        quit
    } if

    % the following block runs only once, because
    % we have the assertion of length 1 above.
    currentdict {
        % forall gives: (key, value)
        pop % pop the value, leaves key on stack
    } forall

    100 string cvs % convert to string (+reserve memory)
} def

% Procedure to exclude Attributes
% SE extractAttributes: tagWithAttributes -- tag attributes
/extractAttributes {
	% Search for a single whitespace character
	( ) search { % then-branch of ifelse
    	% Stack contents: post, match, pre
		exch
        % Stack contents: post, pre, match
		pop
        % Stack contents: post, pre
		exch
        % Stack contents: pre, post
	} { % else-branch of ifelse
        % Element has no attributes (store empty string)
		()
	} ifelse
} def

% Procedure to store Tag as Dictionairy
/prepareTag {
        (prepareTag) comment
        % Local variables dict has two entries (attributes + tagname)
	100 dict begin

    extractAttributes
	
	/attributes exch def

	% store pre (= name of tag) in variable
	/tagname exch def

        /newdict 100 dict def

        tagname attributes tagOpen

	% store into new dictionary
	newdict begin
	    tagname attributes def % store tag on dictionary-stack
	end

        newdict % push newdict to operand stack

	end % 2 dict (lokale variablen)

        begin % pop top of operand stack (= newdict) + push on dict stack
} def

% Procedure to handle End-Tag
% SE handleEndTag: endTag --
/handleEndTag {
        dup (') exch (handleEndTag: ') printa printa comment

        currentdict % push top of dict stack to operand stack

	10 dict begin
           /lastdict exch def
           /endTag exch def

           % should the top-of-dict be droppped? (default yes)
           /dropTag true def

           % is "endTag" in the last opened dict?
           lastdict endTag known {
               (found on top) comment
           } { % else
               endTag where {
                   /founddict exch def
                   (found somewhere) comment
               } { % else
                   /dropTag false def
                   (not found) comment
               } ifelse
           } ifelse

           endTag % for the check
           dropTag % for the if (-> is a boolean already)
	end % 1 dict

        {
            (drop until tag found) comment
            % here: endTag on top of stack
            {
                dup currentdict exch known {
                    (found on top) comment
                    % endtag is on currentdict
                    lastTagName tagClose
                    end
                    exit
                } { % else
                    (still not found) comment
                    lastTagName tagClose
                    end
                } ifelse
            } loop
        } {
            (ignoring end tag) comment
            dup tagIgnore
        } ifelse % if droptag, "pop from dict stack"

        % here: endTag still on top of stack -> pop
        pop
} def

% Extracts Comment
%SE handleComment: comment --
/handleComment {
	(--) search {
		dup (') exch (handlComment: ') printa printa comment
		tagComment
		pop
	} {
		pop
	} ifelse
} def

% Extracts PI
%SE handlePI: PI --
/handlePI {
	(?) search {
		dup (') exch (handlPI: ') printa printa comment
		tagPI
		pop
	} {
		pop
	} ifelse
	
} def

% Extracts Data by Removing heading Spaces and Tabs
%SE handleData: data --
/handleData {
	{
		dup
		<20> search {
			%if length of pre is 0 then eliminate Space
			dup length 0 eq {
				pop pop		% pop pre, space
				exch pop
			} {
				pop	pop	pop
				exit
			} ifelse
		} {
			pop
			exit
		} ifelse
	} loop
	{
		dup
		<09> search {
			%if length of pre is 0 then eliminate Space
			dup length 0 eq {
				pop pop		% pop pre, space
				exch pop
			} {
				pop	pop	pop
				exit
			} ifelse
		} {
			pop
			exit
		} ifelse
	} loop
	
	dup length 0 gt {
		tagData
	} {
		pop
	} ifelse
} def

% Define Procedure for handling SearchTerm
% SE analyzeSearchResult: pre --
/analyzeSearchResult {
	% searching for PI
	(<?) search {
		% PI found
		% Comment found
		handleData
		pop		% pop <!--
		handlePI
	}
	{
		% searching for comment
		(<!--) search {
			% Comment found
			handleData
			pop		% pop <!--
			handleComment
		}
		{
			% searching for '</' in pre 	(SE search: string -- post match pre true
	    	%                                        OR string -- false)
			(</) search {
				% EndTag Found
				handleData
				pop		% pop '</'
				handleEndTag
			} % if-path search
			{ % else-path search
				(<) search { % search for BeginTag
					handleData
					pop		% pop '<'
					dup
					(/) search { % search for BeginEndTag
						exch pop % removes '/'
						
						% check if length of post is 0
						exch length 0 eq {
							extractAttributes
							tagOpenClose
						} {
							pop
							prepareTag
						} ifelse
					}
					{
						pop
						prepareTag
					} ifelse
				}
				{
					pop
				} ifelse
			} ifelse
		} ifelse
	} ifelse
} def

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UNUSED
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% prints a dictionary
% SE printDictionary dictionary  –-
/printDictionary { %def
	(\nDictionary: \n) print
	{ %forall
            % name value
            exch
            (=>)
            exch
            = print =
    } forall
} bind def

% prints the top of a dictionary
% SE printDictionary dictionary  –-
/printDictionaryTop { %def
	(\nDictionary Top: \n) print
	{ %forall
		exch % name first
	    (key: ) print ==
	    %( = ) print
	    (val: ) print ==
		exit
    } forall
} bind def

% Reads the path to a file from stdin
% SE readPathToInputFile:  -- path
/readPathToInputFile {
    % TODO: comment out, hardcoded for testing-purposes
	(Pfad zur XML-Datei: ) print flush
    (%stdin) (r) file 100 string readline pop
%	(input/valid2.xml)
} def

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UNUSED
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% SE: tagname attributes --
/tagOpen {
	% output <tagname 
	exch (<) print print 
	
	% check if there are attributes
	dup () eq {
		% no attributes 
		print (>) =
	} { % else
		( ) print print (>) =
	} ifelse
} def

/tagOpenClose {
	% output tag in the form <tagname attributes />
    exch (<) print print ( ) print print (/>) =
} def

% SE: data --
/tagData {
	% output data
	=
} def

% SE: comment --
/tagComment {
	% output comment in the form <!-- comment -->
    ( -->) exch (<!-- ) print print =
} def

% SE: picontent --
/tagPI {
	% print Processing Instruction in the form <? PI ?>
    ( ?>) exch (<? ) print print =
} def

% SE: tagName --
/tagIgnore {
    % FIXME: Output closing tag as "strikethrough"
	pop
} def

% SE: tagName --
/tagClose {
	% output closing tag in the form </tagname>
    (>) exch (</) print print =
} def

/sentinelKey (itsTheEndOfTheDoc) def

/sentinelOpen {
    /sentinel 1 dict def
    sentinel begin
    sentinelKey (..as we know it) def
} def

/sentinelClose {
    % dictstack abbauen, bis sentinel gefunden
    {
        currentdict sentinelKey known {
            exit
        } if

        lastTagName tagClose
        end
    } loop

    end  % end sentinel
} def

% SE: --
/checkCLIParams {
    1 dict begin
        % SE: [list of parameters] --
        /requireParameters {
            {
                dup systemdict exch known not {
                    (Missing parameter: -d ) print =
                    quit
                } if
            } forall
        } def

        % List all required parameters here
        [
            (inputFilename)
        ] requireParameters
    end
} def

% Main-Procedure
% SE main:  --
/main {
        /locals 100 dict def

        checkCLIParams

        locals begin
        /buffer 128 string def				%setup buffer for readline

        sentinelOpen
	currentfile buffer readline

        locals begin
            /input inputFilename (r) file def
        end

	{ % start loop
                locals begin
                    /buffer 128 string def				%setup buffer for readline
                end

		% reading one line (SE readline: input buffer -- string bool)
		input buffer readline {
			{ %start loop for multiple tags in one line
				% searching for '>'	(SE search: string -- post match pre true
		    	%                            OR string -- false)
				(>) search {
					analyzeSearchResult
					pop		% pop match ( > Sign )
				} % if-path
				{ % else-path (search)
					handleData						% pops string of search command
					exit					% and exits loop
				} ifelse
			} loop
		}
		{ % else-path (readline)
			pop		% pops string for readline command
			exit	% and exits loop
		} ifelse
	} loop

	% close File
	input closefile

    sentinelClose

    end % end of locals

    quit

} def

% call main-procedure
main
% make object executable
